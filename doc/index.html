<!doctype html>
<meta charset=utf-8>
<link rel=stylesheet href=maker.css>

<title>Dai Stablecoin Purple Paper</title>

<header>
<center>
<img src=makerdao.svg>
<p class=x2>REFERENCE<br>IMPLEMENTATION</p>
<p class=x5>of the decentralized</p>
<p class=x4>DAI STABLECOIN</p>
<p class=x5>issuance system</p>
<p class=x6>Nikolai Mushegian<br>Daniel Brockman<br>Mikael Brockman</p>
<p class=x7>[draft; 2017-06-03]</p>
<p class=x8>â—ˆ</p>
</center>
</header>

<div style="font-size: 180%">Contents</div>
<toc>
</toc>

<section>
<h1>Introduction</h1>

<p>The <b>Dai stablecoin system</b> is a set of blockchain smart
contracts designed to issue a token (called the dai) and subject its
price to a decentralized stability mechanism.

<p>This document is an executable and interactive technical
specification of the system.  It is a draft and will change
before launch.

<p>For an overview of the system, see the <a
href="https://github.com/makerdao/docs/blob/master/Dai.md">white
paper</a>.

<p>For a "choose your own adventure" exploration of the system's
mechanics, please wait for the interactive FAQ.

<p>We are dedicated to providing material for new people to understand
the system in depth.  This will be important for successful governance
in the project's future.

<p>If you have any questions, ask on our <a
href="https://chat.makerdao.com">chat</a> or <a
href="https://reddit.com/r/MakerDAO">subreddit</a>.  Asking helps us
work on our explanatory material, so we appreciate it.

</section><section>

<h2>Why a reference implementation?</h2>

<p>The contracts that will be deployed on the Ethereum blockchain are
written in Solidity.  This paper is a model of the system written as a
Haskell program.  The motivations for this include:

<p><b>Comparison.</b>
Checking two free-standing implementations
against each other is a well-known way of ensuring that they both
behave as intended.

<p><b>Testing.</b> Haskell lets us use powerful testing tools such as
QuickCheck for comprehensively verifying key properties. This is a
middle ground between testing and formal verification.

<p><b>Explicitness.</b> Coding the contract behavior in Haskell, a
purely functional language, enforces explicit description of aspects
which Solidity leaves implicit.

<p><b>Typing.</b> Solidity's type system can't encode all the
distinctions made by our system.

<p><b>Formality.</b> The work of translating into a purely functional
program opens up opportunities for formal verification.  This document
will be useful for modelling aspects of the system in a proof
assistant like Isabelle.

<p><b>Clarity.</b>
An implementation not intended to be deployed
on the blockchain is free from concerns about optimizing for gas cost
and other factors that make the Solidity implementation less ideal as
an understandable specification.

<p><b>Simulation.</b> Solidity is specific to the blockchain
environment and lacks facilities for interfacing with files or other
programs.  A reference implementation is useful for doing simulations
of the system's economic, game-theoretic, or statistical aspects.

<h2>What are the limitations of this model?</h2>

<p>This model is limited in that it has

<p><ul>
<li>a simplified version of authorization for governance;
<li>a simplified version of ERC20 token semantics;
<li>no implementation of the decentralized auction contracts;
<li>and no 256-bit word limits.
</ul>

<p>These limitations will be addressed in future revisions.

<h2>On formal verification and steps thereto</h2>

<p>Separately from this document, we are developing automatic test
suites that generate interaction sequences for property verification.

<p>One such property is that the reference implementation behaves like
the on-chain implementation. We verify this by generating Solidity
test cases with equality assertions for the entire state.

<p>Other key properties include

<ul>
<li>that the target price changes according to the target rate;
<li>that the total dai supply is fully accounted for;
<li>that acts are restricted with respect to risk stage;
</ul>

<p>along with similar invariants and conditions.  A future revision of
this document will include formal statements of these properties.

<h2>Note on jargon</h2>

<p>The implementation is formulated in terms of a parallel vocabulary
of concise words like <code>Urn</code>, <code>par</code>, and
<code>ink</code>.  These words are selected for metaphoric resonance
and evocative qualities.  Definitions of the words along with mnemonic
reminders can be found in the glossary.

<p>We have found that though it requires some initial learning, the
jargon is good for development and helps when thinking and talking
about the structure and mechanics of the system.  Here are some of the
reasons:

<p><ul>

<li>The parallel jargon
 lets us sidestep
  terminological debates; for example, whether to say
  &raquo;rate of target price change&laquo; or
   &raquo;target rate&laquo;.

<li>With decoupled
 financial and technical
  vocabularies,
 we can more flexibly
  improve one
   without affecting the other.

<li>The ability to discuss the system formally,
 with the financial interpretation partly suspended,
  has suggested insights that would have been
   harder to think of inside the normal language. 

<li>The precise and distinctive language
 makes the structure and logic
  of the implementation
   more apparent
    and easier to formalize.

</ul>

</section><section>
<h1>Preamble and data types</h1>

<!--

<pre>
{-# Language AllowAmbiguousTypes #-}
{-# Language ConstraintKinds #-}
{-# Language DeriveGeneric #-}
{-# Language DuplicateRecordFields #-}
{-# Language FlexibleContexts #-}
{-# Language FlexibleInstances #-}
{-# Language FunctionalDependencies #-}
{-# Language GeneralizedNewtypeDeriving #-}
{-# Language ImplicitParams #-}
{-# Language LambdaCase #-}
{-# Language MultiWayIf #-}
{-# Language NoMonomorphismRestriction #-}
{-# Language RankNTypes #-}
{-# Language RecordWildCards #-}
{-# Language ScopedTypeVariables #-}
{-# Language StandaloneDeriving #-}
{-# Language TemplateHaskell #-}
{-# Language TypeFamilies #-}
</pre>
-->

<p>This program uses some symbols defined in external libraries.
Most symbols should be clear in context, but our "prelude" lists and
briefly explains each imported type and function.

<todo>Render the prelude.</todo>

<pre>
module Maker where

import Prelude (); import Maker.Prelude; import Maker.Decimal
</pre>
<!--

<pre>
import Debug.Trace
import Data.Aeson.Types (fieldLabelModifier, defaultOptions, genericParseJSON, genericToJSON)
import Prelude (drop)
</pre>
-->

<!--
<p>Haskell syntax note: <code>newtype</code> defines a type synonym with distinct
type identity; <code>data</code> creates a record type; and <code>deriving</code> creates
automatic instances of common functionality.
-->

<h2>Numeric types</h2>

<p>The system uses two precisions of decimal numbers, to which we have
given short mnemonic names.

<p>One is called <em>wad</em> and has 18 digits of precision.  It is
used for token quantities, such as amounts of ETH, DAI, or MKR.

<p>The other is called <em>ray</em> and has 36 digits of precision.
It is used for precise rates and ratios, such as the stability
fee parameter.

<p>We define these as distinct types.  The type system will prevent us
from mixing them up unintentionally.

<pre>
newtype Wad = Wad (Decimal E18)
  deriving (Ord, Eq, Num, Real, Fractional, RealFrac)

newtype Ray = Ray (Decimal E36)
  deriving (Ord, Eq, Num, Real, Fractional, RealFrac)
</pre>
<p>We define a generic function for converting one of these types to
the other.

<pre>
cast x = fromRational (toRational x) -- [Via fractional $n/m$ form]
</pre>
<!--

<pre>
instance Read Ray where
  readsPrec n s = fmap (first Ray) (readsPrec n s)
instance Read Wad where
  readsPrec n s = fmap (first Wad) (readsPrec n s)
instance Read Sec where
  readsPrec n s = fmap (first Sec) (readsPrec n s)

instance Show Wad  where show (Wad x)  = show x
instance Show Ray  where show (Ray x)  = show x
instance Show Sec  where show (Sec x)  = show x
</pre>
<pre>
instance Epsilon Wad  where epsilon = Wad epsilon
instance Epsilon Ray  where epsilon = Ray epsilon
</pre>
-->

<p>We also define a type for time durations in whole seconds.

<pre>
newtype Sec = Sec Int
  deriving (Eq, Ord, Enum, Num, Real, Integral)
</pre>
<h2>Identifiers and addresses</h2>

<p>The following common Haskell idiom lets us use <code>Id Ilk</code>
and <code>Id Urn</code> as distinct identifier types without
code duplication.

<pre>
newtype Id a = Id String
  deriving (Eq, Ord, Show)
</pre>
<p>We define another type for representing Ethereum account addresses.

<pre>
newtype Address = Address String
  deriving (Eq, Ord, Show)
</pre>
<h2>Token types</h2>

<p>The system makes use of four basic types of tokens.  These tokens
are called <b>gems</b>, because they are precious.

<pre>
data Gem

  = Gem String  -- Asset token
  | DAI         -- Public stablecoin
  | MKR         -- Countercoin and voting token
  | SIN         -- Private anticoin

  deriving (Eq, Ord, Show)
</pre>
<p>The asset tokens are used as collateral, and are written in the
form <code>Gem "ETH"</code>.  The model treats all asset tokens as
basic ERC20 tokens differing only in ticker symbol.  In reality,
voters should make sure that asset tokens are well-behaved.


<h2>Actors</h2>

<p>We use a data type to explicitly distinguish the different entities
that can hold a token balance or invoke acts.

<pre>
data Actor
  = Account Address  -- External holder
  | Jar              -- Token vault
  | Jug              -- Mints stablecoin/anticoin, holds anticoin
  | Vow              -- Settler
  | Flipper          -- Asset auctioneer
  | Flapper          -- Stablecoin auctioneer
  | Flopper          -- Countercoin auctioneer
  | Toy              -- Test driver
  | God              -- Omnipotent actor

  deriving (Eq, Ord, Show)
</pre>



<!--

<pre>
instance Read (Id a) where
  readsPrec n s = fmap (first Id) (readsPrec n s)
</pre>
<pre>
deriving instance Generic Wad
deriving instance Generic Ray
deriving instance Generic Sec
deriving instance Generic (Id a)
deriving instance Generic Address
deriving instance Generic Gem
</pre>

-->

<h2><code>Urn</code>: CDP bookkeeping record</h2>

<p>An <code>urn</code> record defines a basic entity through which
users interact with the system to issue stablecoin.  Each urn belongs
to an ilk.  The urn records the value of locked assets along with
the amount of stablecoin created for this particular urn.
When liquidation is triggered on an urn, the identity of the triggering
entity is also recorded.

<pre>
data Urn = Urn {
  _ilk  :: Id Ilk,      -- Urn type
  _lad  :: Actor,       -- Urn owner
  _art  :: Wad,         -- Stablecoin issuance in fee unit
  _ink  :: Wad,         -- Amount of locked assets
  _cat  :: Maybe Actor  -- Actor that triggered liquidation, if applicable
} deriving (Eq, Show)
</pre>
<h2><code>Ilk</code>: CDP type parameters</h2>

<p>Each urn belongs to an urn type, specified by an <code>Ilk</code>
record.

<p>Five parameters, <code>mat</code>, <code>axe</code>,
<code>hat</code>, <code>tax</code> and <code>lax</code>, are set by
governance and are known as the <em>risk parameters</em>. The rest of
the values are used by the system to keep track of the current state.

<p>The meaning of each <code>ilk</code> parameter is defined by its
interactions in the act definitions of
Chapter&nbsp;\ref{chapter:acts}; see the whitepaper for an overview.

<pre>
data Ilk = Ilk {
  _gem :: Gem,   -- Asset identifier
  _lax :: Sec,   -- Grace period after price feed becomes unavailable
  _mat :: Ray,   -- Urn liquidation ratio of locked value to issued value
  _axe :: Ray,   -- Urn liquidation penalty as fraction of urn issuance
  _hat :: Wad,   -- Maximum total issuance for ilk ("issuance ceiling")
  _tax :: Ray,   -- Stability fee as per-second fraction of urn issuance
  _chi :: Ray,   -- Value of fee unit in stablecoin
  _rho :: Sec,   -- Time of latest fee unit adjustment
  _rum :: Wad    -- Total ilk issuance denominated in fee unit
} deriving (Eq, Show)
</pre>
<h2><code>Vox</code>: feedback mechanism data</h2>

<p>The <em>feedback mechanism</em> is the aspect of the system that
adjusts the target price of dai based on market price. Its data is
grouped in a record called <code>Vox</code>.

<pre>
data Vox = Vox {
  _wut   :: Wad,    -- Stablecoin market price denominated in SDR
  _par   :: Wad,    -- Stablecoin target price denominated in SDR
  _way   :: Ray,    -- Current per-second change in target price
  _how   :: Ray,    -- Sensitivity parameter set by governance
  _tau   :: Sec     -- Timestamp of latest feedback iteration
} deriving (Eq, Show)
</pre>
<h2><code>Tag</code>: asset price record</h2>

<p>The data received from price feeds is categorized by token and
stored in <code>Tag</code> records.

<pre>
data Tag = Tag {
  _tag :: Wad,  -- Market price denominated in SDR
  _zzz :: Sec   -- Time of price expiration
} deriving (Eq, Show)
</pre>
<h2><code>Vat</code>: system root</h2>

<p>The <code>Vat</code> record aggregates the records of tokens, urns,
ilks, and price feeds, along with the data of the feedback mechanism.

<pre>
data Vat = Vat {
  _tags  :: Map Gem Tag,        -- Asset price feeds
  _ilks  :: Map (Id Ilk) Ilk,   -- Urn type records
  _urns  :: Map (Id Urn) Urn,   -- Urn records
  _vox   :: Vox                 -- Feedback mechanism data
} deriving (Eq, Show)
</pre>
<h2>System model</h2>

<p>Finally we define a record with no direct counterpart in the
Solidity contracts, which has the <code>Vat</code> record along with
model state.

<pre>
data System =  System {
  _balances  :: Map (Actor, Gem) Wad,  -- Token balances
  _vat       :: Vat,                   -- Root entity
  _era       :: Sec,                   -- Current time stamp
  _sender    :: Actor,                 -- Sender of current act
  _accounts  :: [Address],             -- For test suites
  _mode      :: Mode                   -- Vow operation mode
} deriving (Eq, Show)

data Mode = Dummy
  deriving (Eq, Show)
</pre>
<!--

<pre>
deriving instance Generic Tag
deriving instance Generic Actor
deriving instance Generic Ilk
deriving instance Generic Urn
deriving instance Generic Vox
deriving instance Generic Vat
deriving instance Generic System
deriving instance Generic Mode
</pre>
<pre>
instance HasResolution a =&gt; ToJSON (Decimal a) where
  toJSON (D x) = toJSON (show x)

instance HasResolution a =&gt; FromJSON (Decimal a) where
  parseJSON v = fmap (D . read) (parseJSON v)

instance ToJSON Sec where
  toJSON (Sec x) = toJSON (show x)

instance FromJSON Sec where
  parseJSON v = fmap (Sec . read) (parseJSON v)

instance ToJSONKey Gem    ; instance FromJSONKey Gem
instance ToJSONKey Actor ; instance FromJSONKey Actor
instance ToJSONKey (Id a) ; instance FromJSONKey (Id a)

instance ToJSON Wad
instance FromJSON Wad
instance ToJSON Ray
instance FromJSON Ray
instance ToJSON Address
instance FromJSON Address
instance ToJSON (Id a)
instance FromJSON (Id a)
instance ToJSON Actor
instance FromJSON Actor
instance ToJSON Gem
instance FromJSON Gem
instance ToJSON Tag where { toJSON = genericToJSON defaultOptions { fieldLabelModifier = drop 1 } }
instance FromJSON Tag where { parseJSON = genericParseJSON defaultOptions { fieldLabelModifier = drop 1 } }
instance ToJSON Ilk where { toJSON = genericToJSON defaultOptions { fieldLabelModifier = drop 1 } }
instance FromJSON Ilk where { parseJSON = genericParseJSON defaultOptions { fieldLabelModifier = drop 1 } }
instance ToJSON Urn where { toJSON = genericToJSON defaultOptions { fieldLabelModifier = drop 1 } }
instance FromJSON Urn where { parseJSON = genericParseJSON defaultOptions { fieldLabelModifier = drop 1 } }
instance ToJSON Vox where { toJSON = genericToJSON defaultOptions { fieldLabelModifier = drop 1 } }
instance FromJSON Vox where { parseJSON = genericParseJSON defaultOptions { fieldLabelModifier = drop 1 } }
instance ToJSON Vat where { toJSON = genericToJSON defaultOptions { fieldLabelModifier = drop 1 } }
instance FromJSON Vat where { parseJSON = genericParseJSON defaultOptions { fieldLabelModifier = drop 1 } }
instance ToJSON Mode
instance FromJSON Mode
instance ToJSON System where { toJSON = genericToJSON defaultOptions { fieldLabelModifier = drop 1 } }
instance FromJSON System where { parseJSON = genericParseJSON defaultOptions { fieldLabelModifier = drop 1 } }
</pre>
<h3>Lens fields</h3>

<pre>
makeLenses ''Tag  ; makeLenses ''Ilk
makeLenses ''Urn    ; makeLenses ''Vox  ; makeLenses ''Vat
makeLenses ''System
</pre>
<pre>
balance id_gem entity = balances . ix (entity, id_gem)
</pre>
-->

<h2>Default data</h2>

<pre>
defaultIlk :: Gem -&gt; Ilk
defaultIlk id_gem = Ilk {
  _gem = id_gem,
  _axe = Ray 1,
  _mat = Ray 1,
  _tax = Ray 1,
  _hat = Wad 0,
  _lax = Sec 0,
  _chi = Ray 1,
  _rum = Wad 0,
  _rho = Sec 0
}
</pre>
<pre>
emptyUrn :: Id Ilk -&gt; Actor -&gt; Urn
emptyUrn id_ilk id_lad = Urn {
  _cat = Nothing,
  _lad = id_lad,
  _ilk = id_ilk,
  _art = Wad 0,
  _ink = Wad 0
}
</pre>
<pre>
initialTag :: Tag
initialTag = Tag {
  _tag = Wad 0,
  _zzz = 0
}
</pre>
<pre>
initialVat :: Ray -&gt; Vat
initialVat how0 = Vat {
  _vox = Vox {
    _tau = 0,
    _wut = Wad 1,
    _par = Wad 1,
    _how = how0,
    _way = Ray 1
  },
  _ilks = empty,
  _urns = empty,
  _tags = empty
}
</pre>
<pre>
initialSystem :: Ray -&gt; System
initialSystem how0 = System {
  _balances = empty,
  _vat      = initialVat how0,
  _era      = 0,
  _sender   = God,
  _accounts = mempty,
  _mode     = Dummy
}
</pre>
<h1>Acts</h1>

<p>The <em>acts</em> are the basic state transitions of the system.

<p>Unless specified as <em>internal</em>, acts are accessible as public
functions on the blockchain.

<p>The <code>auth</code> modifier marks acts which can only be invoked
from addresses to which the system has granted authority.

<p>For details on the underlying &raquo;Action monad&laquo; which
specifies how the act definitions behave with regard to state and
rollback, see chapter&nbsp;\ref{chapter:monad}.

<h2>Assessment</h2>

<p>In order to prohibit urn acts based on risk situation, we define
these stages of risk.

<pre>
data Stage
  = Pride  -- No problems
  | Anger  -- Issuance ceiling reached
  | Worry  -- Asset price feed in limbo
  | Panic  -- Price limbo limit exceeded, or undercollateralized
  | Grief  -- Liquidation triggered
  | Dread  -- Liquidation started
  deriving (Eq, Show)
</pre>
<!--

<pre>
deriving instance Generic Stage
</pre>
-->

<h3>Risk stage effects</h3>

<center>
<table>
<thead>
<th></th>
<th><code>give</code>
<th><code>shut</code>
<th><code>lock</code>
<th><code>wipe</code>
<th><code>free</code>
<th><code>draw</code>
<th><code>bite</code>
<th><code>grab</code>
<th><code>plop</code>
</thead>
<tbody>
<tr><td><code>Pride</code><td>yah<td>yep<td>yep<td>yep<td>meh<td>meh<td>nah<td>nah<td>nah
<tr><td><code>Anger</code><td>yah<td>yep<td>yep<td>yep<td>meh<td>nah<td>nah<td>nah<td>nah
<tr><td><code>Worry</code><td>yah<td>yep<td>yep<td>yep<td>nah<td>nah<td>nah<td>nah<td>nah
<tr><td><code>Panic</code><td>yah<td>yep<td>yep<td>yep<td>nah<td>nah<td>woo<td>nah<td>nah
<tr><td><code>Grief</code><td>yah<td>nah<td>nah<td>nah<td>nah<td>nah<td>nah<td>hey<td>nah
<tr><td><code>Dread</code><td>yah<td>nah<td>nah<td>nah<td>nah<td>nah<td>nah<td>nah<td>hey
</tbody>
</table>
</center>

<h3>Risk stage analysis</h3>

<p>We define the function <code>analyze</code> that determines the
risk stage of an urn.

<pre>
analyze era0 par0 urn0 ilk0 tag0 =

  if | has cat urn0 &amp;&amp; view ink urn0 == 0
        -&gt; Dread
     | has cat urn0
        -&gt; Grief
     | pro &lt; min
        -&gt; Panic
     | view zzz tag0 + view lax ilk0 &lt; era0
        -&gt; Panic
     | view zzz tag0 &lt; era0
        -&gt; Worry
     | cap &gt; view hat ilk0
        -&gt; Anger
     | otherwise
        -&gt; Pride

  where

   -- Value of urn's locked asset in SDR:
    pro = view ink urn0 * view tag tag0

   -- Ilk's total stablecoin issuance in DAI:
    cap = view rum ilk0 * cast (view chi ilk0)

   -- Urn's stablecoin issuance denominated in SDR:
    con = view art urn0 * cast (view chi ilk0) * par0

   -- Required asset value as per liquidation ratio:
    min = con * cast (view mat ilk0)
</pre>
<!--
\newcommand{\yah}{\faHandPeaceO}
\newcommand{\yep}{\faHandScissorsO}
\newcommand{\hey}{\faHandGrabO}
\newcommand{\meh}{\faHandPointerO}
\newcommand{\woo}{\faHandPaperO}
\newcommand{\nah}{---}
\begin{table}[t]
\caption{Urn acts and risk stages}\label{table:stages}
\vspace{0.25cm}
%\resizebox{\textwidth}{!}{%
\begin{tabular}{ r c c c c c c c c c }
       &|give|&|shut|&|lock|&|wipe|&|free|&|draw|&|bite|&|grab|&|plop| \\
|Pride|&\yah  &\yep  &\yep  &\yep  &\meh  &\meh  &\nah  &\nah  &\nah \\
|Anger|&\yah  &\yep  &\yep  &\yep  &\meh  &\nah  &\nah  &\nah  &\nah \\
|Worry|&\yah  &\yep  &\yep  &\yep  &\nah  &\nah  &\nah  &\nah  &\nah \\
|Panic|&\yah  &\yep  &\yep  &\yep  &\nah  &\nah  &\woo  &\nah  &\nah \\
|Grief|&\yah  &\nah  &\nah  &\nah  &\nah  &\nah  &\nah  &\hey  &\nah \\
|Dread|&\yah  &\nah  &\nah  &\nah  &\nah  &\nah  &\nah  &\nah  &\hey \\
&  &
\multicolumn{3}{c}{decrease risk} &
\multicolumn{2}{c}{increase risk} &
\multicolumn{3}{c}{unwind risk}
\end{tabular} %}
\vspace{0.5cm}
\caption*{
\begin{tabular} { c l }
\woo & allowed for anyone \\
\yah & allowed for owner unconditionally \\
\yep & allowed for owner if able to pay \\
\meh & allowed for owner if above liquidation ratio \\
\hey & allowed for settler contract \\
\end{tabular}
}
\end{table}
-->

<p>Now we define the internal act <code>feel</code> which returns the
value of <code>analyze</code> after ensuring that the system state
is updated.

<pre>
feel id_urn = do
  
 -- Adjust target price and target rate
  prod

 -- Update fee unit and unprocessed fee revenue
  id_ilk &lt;- look (vat . urns . ix id_urn . ilk)
  drip id_ilk

 -- Read parameters for risk analysis
  era0 &lt;- use era
  par0 &lt;- use (vat . vox . par)
  urn0 &lt;- look (vat . urns . ix id_urn)
  ilk0 &lt;- look (vat . ilks . ix (view ilk urn0))
  tag0 &lt;- look (vat . tags . ix (view gem ilk0))

 -- Return risk stage of urn
  return (analyze era0 par0 urn0 ilk0 tag0)
</pre>
<p>Urn acts use <code>feel</code> to prohibit increasing risk when
already risky, and to freeze stablecoin and assets during liquidation;
see Table&nbsp;\ref{table:stages}.

<h2>Issuance</h2>

<p>Any user can open one or more accounts with the system using
<code>open</code>, specifying a self-chosen account identifier and
an ilk.

<pre>
open id_urn id_ilk = do

 -- Fail if account identifier is taken
  none (vat . urns . ix id_urn)

 -- Fail if ilk type is not present
  _ &lt;- look (vat . ilks . ix id_ilk)

 -- Create an urn with the sender as owner
  id_lad &lt;- use sender
  initialize (vat . urns . at id_urn) (emptyUrn id_ilk id_lad)
</pre>
<p>The owner of an urn can transfer its ownership at any time using
<code>give</code>.

<pre>
give id_urn id_lad = do

 -- Fail if sender is not the urn owner
  id_sender &lt;- use sender
  owns id_urn id_sender

 -- Transfer urn ownership
  assign (vat . urns . ix id_urn . lad) id_lad
</pre>
<p>Unless urn is in liquidation, its owner can use <code>lock</code> to
lock more asset.

<pre>
lock id_urn wad_gem = do

 -- Fail if sender is not the urn owner
  id_lad &lt;- use sender
  owns id_urn id_lad

 -- Fail if liquidation in process
  want (feel id_urn) (anythingBut [Grief, Dread])

 -- Identify asset token
  id_ilk  &lt;- look (vat . urns . ix id_urn . ilk)
  id_gem  &lt;- look (vat . ilks . ix id_ilk . gem)

 -- Take custody of assets
  transfer id_gem wad_gem id_lad Jar

 -- Record an asset token balance increase
  increase (vat . urns . ix id_urn . ink) wad_gem
</pre>
<p>When an urn has no risk problems (except that its ilk's ceiling may
be exceeded), its owner can use <code>free</code> to reclaim some
amount of assets, as long as this would not take the urn below its
liquidation ratio.

<pre>
free id_urn wad_gem = do

 -- Fail if sender is not the urn owner
  id_lad &lt;- use sender
  owns id_urn id_lad

 -- Record an asset token balance decrease
  decrease (vat . urns . ix id_urn . ink) wad_gem

 -- Roll back on any risk problem except ilk ceiling excess
  want (feel id_urn) (`elem` [Pride, Anger])

 -- Release custody of assets
  id_ilk &lt;- look (vat . urns . ix id_urn . ilk)
  id_gem &lt;- look (vat . ilks . ix id_ilk . gem)
  transfer id_gem wad_gem Jar id_lad
</pre>
<p>When an urn has no risk problems, its owner can can use
<code>draw</code> to issue fresh stablecoin, as long as the ilk
ceiling is not exceeded and the issuance would not take the urn below
its liquidation ratio.

<pre>
draw id_urn wad_dai = do

 -- Fail if sender is not the urn owner
  id_lad &lt;- use sender
  owns id_urn id_lad

 -- Update fee unit and unprocessed fee revenue
  id_ilk &lt;- look (vat . urns . ix id_urn . ilk)
  chi1 &lt;- drip id_ilk

 -- Denominate issuance quantity in fee unit
  let wad_chi = wad_dai / cast chi1

 -- Record increase of urn's stablecoin issuance
  increase (vat . urns . ix id_urn . art) wad_chi

 -- Record increase of ilk's stablecoin issuance
  increase (vat . ilks . ix id_ilk . rum) wad_chi

 -- Roll back on any risk problem
  want (feel id_urn) (== Pride)

 -- Mint both stablecoin and anticoin
  lend wad_dai

 -- Transfer stablecoin to urn owner
  transfer DAI wad_dai Jug id_lad
</pre>
<p>An urn owner who has previously issued stablecoin can use
<code>wipe</code> to send back dai and reduce the urn's issuance.

<pre>
wipe id_urn wad_dai = do

 -- Fail if sender is not the urn owner
  id_lad &lt;- use sender
  owns id_urn id_lad

 -- Fail if urn is in liquidation
  want (feel id_urn) (anythingBut [Grief, Dread])

 -- Update fee unit and unprocessed fee revenue
  id_ilk &lt;- look (vat . urns . ix id_urn . ilk)
  chi1 &lt;- drip id_ilk

 -- Denominate stablecoin amount in fee unit
  let wad_chi = wad_dai / cast chi1

 -- Record decrease of urn issuance
  decrease (vat . urns . ix id_urn . art) wad_chi

 -- Record decrease of ilk total issuance
  decrease (vat . ilks . ix id_ilk . rum) wad_chi

 -- Take custody of stablecoin from urn owner
  transfer DAI wad_dai id_lad Jar

 -- Destroy stablecoin and anticoin
  mend wad_dai
</pre>
<p>An urn owner can use <code>shut</code> to close their
account&mdash;reversing all issuance plus fee and reclaiming all
assets&mdash;if the price feed is up to date and the urn is not
in liquidation.

<pre>
shut id_urn = do

 -- Update fee unit and unprocessed fee revenue
  id_ilk &lt;- look (vat . urns . ix id_urn . ilk)
  chi1 &lt;- drip id_ilk

 -- Reverse all issued stablecoin plus fee
  art0 &lt;- look (vat . urns . ix id_urn . art)
  wipe id_urn (art0 * cast chi1)

 -- Reclaim all locked assets
  ink0 &lt;- look (vat . urns . ix id_urn . ink)
  free id_urn ink0

 -- Nullify urn record
  assign (vat . urns . at id_urn) Nothing
</pre>
<h2>Adjustment</h2>

<p>The feedback mechanism is updated through <code>prod</code>, which
can be invoked at any time by keepers, but is also invoked as a side
effect of any urn act that uses <code>feel</code> to assess risk.

<pre>
prod = do

 -- Read all parameters relevant for feedback mechanism
  era0 &lt;- use era
  tau0 &lt;- use (vat . vox . tau)
  wut0 &lt;- use (vat . vox . wut)
  par0 &lt;- use (vat . vox . par)
  how0 &lt;- use (vat . vox . how)
  way0 &lt;- use (vat . vox . way)

  let
   -- Time difference in seconds
    age  = era0 - tau0

   -- Current target rate applied to target price
    par1  = par0 * cast (way0 ^^ age)

   -- Sensitivity parameter applied over time
    wag  = how0 * fromIntegral age

   -- Target rate scaled up or down
    way1  = inj (prj way0 +
                 if wut0 &lt; par0 then wag else -wag)

 -- Update target price
  assign (vat.vox.par) par1

 -- Update rate of price change
  assign (vat.vox.way) way1

 -- Record time of update
  assign (vat.vox.tau) era0

  where
   -- Convert between multiplicative and additive form
    prj x  = if x &gt;= 1  then x - 1  else 1 - 1 / x
    inj x  = if x &gt;= 0  then x + 1  else 1 / (1 - x)
</pre>
<p>The stability fee of an ilk can change through governance.  Due to
the constraint that acts should run in constant time, the system
cannot iterate over urns to effect such changes.  Instead each ilk has
a single &raquo;fee unit&laquo; which accumulates the stability fee.
The <code>drip</code> act updates this unit.  It can be called at any
time by keepers, but is also called as a side effect of every act that
uses <code>feel</code> to assess urn risk.

<pre>
drip id_ilk = do

  rho0  &lt;- look (vat . ilks . ix id_ilk . rho)
  tax0  &lt;- look (vat . ilks . ix id_ilk . tax)
  chi0  &lt;- look (vat . ilks . ix id_ilk . chi)
  rum0  &lt;- look (vat . ilks . ix id_ilk . rum)
  era0  &lt;- use era

  let
   -- Time difference in seconds
    age   = era0 - rho0
   -- Value of fee unit increased according to stability fee
    chi1  = chi0 * tax0 ^^ age
   -- Stability fee revenue denominated in new unit
    dew   = (cast (chi1 - chi0) :: Wad) * rum0

 -- Mint stablecoin and anticoin for marginally accrued fee
  lend dew

 -- Record time of update
  assign (vat . ilks . ix id_ilk . rho) era0

 -- Record new fee unit
  assign (vat . ilks . ix id_ilk . chi) chi1

 -- Return the new fee unit
  return chi1
</pre>
<h2>Price feed input</h2>

<p>The <code>mark</code> act records a new market price of an
asset along with the expiration date of this price.

<pre>
mark id_gem tag1 zzz1 = auth $ do
  initialize (vat . tags . at id_gem) Tag {
    _tag  = tag1,
    _zzz  = zzz1
  }
</pre>
<p>The <code>tell</code> act records a new market price of dai along
with the expiration date of this price.

<pre>
tell wad = auth $ do
  assign (vat . vox . wut) wad
</pre>
<h2>Liquidation</h2>

<p>
When an urn's stage marks it
  as in need of liquidation,
 any account can invoke the <code>bite</code> act
  to trigger the liquidation process.
This enables the settler contract
 to grab the assets for auctioning
 and take over the anticoin.

<pre>
bite id_urn = do

 -- Fail if urn is not in the appropriate stage
  want (feel id_urn) (== Panic)

 -- Record the sender as the liquidation initiator
  id_cat &lt;- use sender
  assign (vat . urns . ix id_urn . cat) (Just id_cat)

 -- Apply liquidation penalty to urn issuance
  id_ilk &lt;- look (vat . urns . ix id_urn . ilk)
  axe0 &lt;- look (vat . ilks . ix id_ilk . axe)
  art0 &lt;- look (vat . urns . ix id_urn . art)
  let art1 = art0 * cast axe0

 -- Update urn issuance to include penalty
  assign (vat . urns . ix id_urn . art) art1
</pre>
<p>
After liquidation has been triggered,
the designated settler contract invokes <code>grab</code>
to receive both the urn's assets
and the anticoins
corresponding to the urn's issuance.

<pre>
grab id_urn = auth $ do

 -- Fail if urn is not marked for liquidation
  want (feel id_urn) (== Grief)

  ink0 &lt;- look (vat . urns . ix id_urn . ink)
  art0 &lt;- look (vat . urns . ix id_urn . art)
  id_ilk &lt;- look (vat . urns . ix id_urn . ilk)
  id_gem &lt;- look (vat . ilks . ix id_ilk . gem)

 -- Update the fee unit and unprocessed fee revenue
  chi1 &lt;- drip id_ilk

 -- Denominate the issuance in dai
  let con = art0 * cast chi1

 -- Transfer assets and anticoin to settler
  transfer id_gem ink0 Jar Vow
  transfer SIN con Jar Vow

 -- Nullify urn's asset and anticoin quantities
  assign (vat . urns . ix id_urn . ink) 0
  assign (vat . urns . ix id_urn . art) 0

 -- Decrease the ilk's total issuance
  decrease (vat . ilks . ix id_ilk . rum) art0
</pre>
<p>
When the settler has finished the liquidation of an urn, it invokes
<code>plop</code> to give back any assets it did not need to sell and restore
the urn.

<pre>
plop id_urn wad_dai = auth $ do

 -- Fail unless urn is in the proper stage
  want (feel id_urn) (== Dread)

 -- Forget the urn's initiator of liquidation
  assign (vat . urns . ix id_urn . cat) Nothing

 -- Take excess assets from settler to vault
  id_vow &lt;- use sender
  id_ilk &lt;- look (vat . urns . ix id_urn . ilk)
  id_gem &lt;- look (vat . ilks . ix id_ilk . gem)
  transfer id_gem wad_dai id_vow Jar

 -- Record the excess assets as belonging to the urn
  assign (vat . urns . ix id_urn . ink) wad_dai
</pre>
<p>
The settler can invoke <code>loot</code> at any time
to claim all uncollected stability fee revenue
for use in the countercoin buy-and-burn auction.

<pre>
loot = auth $ do

 -- The dai vault's balance is the uncollected stability fee revenue
  wad &lt;- look (balance DAI Jar)

 -- Transfer the entire dai vault balance to sender
  transfer DAI wad Jar Vow
</pre>
<h2>Auctioning</h2>

<pre>
flip id_gem wad_jam wad_tab id_urn = do
  vow &lt;- look mode
  case vow of
    Dummy -&gt; return ()
</pre>
<pre>
flap = do
  vow &lt;- look mode
  case vow of
    Dummy -&gt; return ()

flop = do
  vow &lt;- look mode
  case vow of
    Dummy -&gt; return ()
</pre>
<h2>Settlement</h2>

<pre>
tidy who = auth $ do

 -- Find the entity's stablecoin and anticoin balances
  awe &lt;- look (balance DAI who)
  woe &lt;- look (balance SIN who)

 -- We can burn at most the smallest of the two balances
  let x = min awe woe

 -- Transfer stablecoin and anticoin to the settler
  transfer DAI x who Vow
  transfer SIN x who Vow

 -- Burn both stablecoin and anticoin
  burn DAI x Vow
  burn SIN x Vow
</pre>
<pre>
kick = do

 -- Transfer unprocessed stability fee revenue to vow account
  loot

 -- Cancel stablecoin against anticoin
  tidy Vow

 -- Assign any remaining stablecoin to countercoin-deflating auction
  transferAll DAI Vow Flapper
  flap

 -- Assign any remaining anticoin to countercoin-inflating auction
  transferAll SIN Vow Flopper
  flop
</pre>
<h2>Governance</h2>

<p>Governance uses <code>form</code> to create a new ilk.  Since the
new type is initialized with a zero ceiling, a separate transaction
can safely set the risk parameters before any issuance occurs.

<pre>
form id_ilk id_gem = auth $ do
  initialize (vat . ilks . at id_ilk) (defaultIlk id_gem)
</pre>
<p>Governance uses <code>frob</code> to alter the sensitivity factor,
which is the only mutable parameter of the feedback mechanism.

<pre>
frob how1 = auth $ do
  assign (vat . vox . how) how1
</pre>
<p>Governance can alter the five risk parameters of an ilk using
<code>cuff</code> for the liquidation ratio; <code>chop</code> for the
liquidation penalty; <code>cork</code> for the ilk ceiling;
<code>calm</code> for the duration of price limbo; and
<code>crop</code> for the stability fee.

<pre>
cuff id_ilk mat1 = auth $ do
  assign (vat . ilks . ix id_ilk . mat) mat1

chop id_ilk axe1 = auth $ do
  assign (vat . ilks . ix id_ilk . axe) axe1

cork id_ilk hat1 = auth $ do
  assign (vat . ilks . ix id_ilk . hat) hat1

calm id_ilk lax1 = auth $ do
  assign (vat . ilks . ix id_ilk . lax) lax1
</pre>
<p>When altering the stability fee with <code>crop</code>, we ensure
that the previous stability fee has been accounted for in the internal
fee unit.

<pre>
crop id_ilk tax1 = auth $ do

 -- Apply the current stability fee to the internal fee unit
  drip id_ilk

 -- Change the stability fee
  assign (vat . ilks . ix id_ilk . tax) tax1
</pre>
<h2>Token manipulation</h2>

<p>We model the ERC20 transfer function in simplified form (omitting
the concept of &raquo;allowance&laquo;).

<pre>
transfer id_gem wad src dst =

 -- Operate in the token's balance table
  zoom balances $ do

 -- Fail if source balance insufficient
  balance &lt;- look (ix (src, id_gem))
  aver (balance &gt;= wad)

 -- Update balances
  decrease    (ix (src, id_gem)) wad
  initialize  (at (dst, id_gem)) 0
  increase    (ix (dst, id_gem)) wad
</pre>
<pre>
transferAll id_gem src dst = do
  wad &lt;- look (balance id_gem src)
  transfer id_gem wad src dst
</pre>
<p>The internal act <code>mint</code> inflates the supply of a token.
It is used by <code>lend</code> to create new stablecoin and anticoin,
and by the settler to create new countercoin.

<pre>
mint id_gem wad dst = do
  initialize (balances . at (dst, id_gem)) 0
  increase   (balances . ix (dst, id_gem)) wad
</pre>
<p>The internal act <code>burn</code> deflates the supply of a token.
It is used by <code>mend</code> to destroy stablecoin and anticoin,
and by the settler to destroy countercoin.

<pre>
burn id_gem wad src =
  decrease (balances . ix (src, id_gem)) wad
</pre>
<p>The internal act <code>lend</code> mints identical amounts of both
stablecoin and anticoin.  It is used by <code>draw</code> to issue
stablecoin; it is also used by <code>drip</code> to issue stablecoin
representing revenue from stability fees, which stays in the vault
until collected.

<pre>
lend wad_dai = do
  mint DAI wad_dai Jug
  mint SIN wad_dai Jug
</pre>
<p>The internal act <code>mend</code> destroys identical amounts of
both dai and the internal debt token.  Its use via <code>wipe</code>
is how the stablecoin supply is reduced.

<pre>
mend wad_dai = do
  burn DAI wad_dai Jug
  burn SIN wad_dai Jug
</pre>
<!--

\section{Manipulation}

<pre>
warp t = auth (do increase era t)
</pre>
<pre>
mine id_gem = do

    initialize (balances . at (Toy, id_gem)) 1000000000000
</pre>
<pre>
hand dst wad_gem id_gem = do
  transfer id_gem wad_gem
    Toy (Account dst)
</pre>
<pre>
sire lad = do prepend accounts lad
</pre>
\section{Other stuff}

<pre>
perform :: Act -&gt; Action ()
perform x =
  let ?act = x in case x of
    Form id gem      -&gt; form id gem
    Mark gem tag zzz -&gt; mark gem tag zzz
    Open id ilk      -&gt; open id ilk
    Tell wad         -&gt; tell wad
    Frob ray         -&gt; frob ray
    Prod             -&gt; prod
    Drip x           -&gt; drip x &gt;&gt;= \_ -&gt; return ()
    Warp t           -&gt; warp t
    Give urn lad     -&gt; give urn lad
    Lock urn wad     -&gt; lock urn wad
    Mine id          -&gt; mine id
    Hand lad wad gem -&gt; hand lad wad gem
    Sire lad         -&gt; sire lad
    Draw lad wad     -&gt; draw lad wad
    Cuff ilk ray     -&gt; cuff ilk ray
    Chop ilk ray     -&gt; chop ilk ray
    Cork ilk wad     -&gt; cork ilk wad
    Calm ilk sec     -&gt; calm ilk sec
    Mint gem wad lad -&gt; mint gem wad lad
</pre>
<pre>
being :: Actor -&gt; Action () -&gt; Action ()
being who x = do
  old &lt;- use sender
  assign sender who
  y &lt;- x
  assign sender old
  return y
</pre>
-->

<h1>Act framework</h1>

<!--

<h2>Act descriptions</h2>

<p>We define the act vocabulary as a data type to
represent invocations.

<pre>
data Act =
     Bite     (Id Urn)
  |  Draw     (Id Urn)  Wad
  |  Form     (Id Ilk)  (Gem)
  |  Free     (Id Urn)  Wad
  |  Frob     Ray
  |  Give     (Id Urn)  Actor
  |  Grab     (Id Urn)
  |  Lock     (Id Urn)  Wad
  |  Loot     Wad
  |  Mark     (Gem)  Wad  Sec
  |  Open     (Id Urn)  (Id Ilk)
  |  Prod
  |  Shut     (Id Urn)
  |  Tell     Wad
  |  Wipe     (Id Urn)  Wad
  |  Mine (Gem)
  |  Hand Address Wad (Gem)
  |  Sire Address
  |  Addr Address
  |  Warp Sec
  |  Cuff (Id Ilk) Ray
  |  Chop (Id Ilk) Ray
  |  Cork (Id Ilk) Wad
  |  Calm (Id Ilk) Sec
  |  Mint Gem Wad Actor
  |  Drip (Id Ilk)
 deriving (Eq, Show)
</pre>
-->

<p>The reader does not need any abstract understanding of monads to
understand the code.  They give us a nice syntax&mdash;the
<code>do</code> block notation&mdash;for expressing exceptions and
state in a way that is still purely functional.  Each line of such a
block is interpreted by the monad to provide the semantics we want.

<h2>The <code>Action</code> monad</h2>

<p>This defines the <code>Action</code> monad as a simple composition
of a state monad and an error monad:

<pre>
type Action a = StateT System (Except Error) a
</pre>
<p>We divide act failure modes into general assertion failures and
authentication failures.

<pre>
data Error = AssertError Act | AuthError
  deriving (Show, Eq)
</pre>
<p>An act can be executed on a given initial system state using
<code>exec</code>.  The result is either an error or a new state.
The <code>exec</code> function can also accept a sequence of acts,
which will be interpreted as a single transaction.

<pre>
exec :: System -&gt; Action () -&gt; Either Error System
exec sys m = runExcept (execStateT m sys)
</pre>
<h2>Asserting</h2>

<p>We now define a set of functions that fail unless some
condition holds.

<pre>
-- General assertion
aver x = unless x (throwError (AssertError ?act))

-- Assert that an indexed value is not present
none x = preuse x &gt;&gt;= \case
  Nothing -&gt; return ()
  Just _  -&gt; throwError (AssertError ?act)

-- Assert that an indexed value is present
look f = preuse f &gt;&gt;= \case
  Nothing -&gt; throwError (AssertError ?act)
  Just x  -&gt; return x

-- Execute an act and assert a condition on its result
want m p = m &gt;&gt;= (aver . p)

has p x = view p x /= Nothing
</pre>
<p>We define <code>owns id_urn id_lad</code> as an assertion that the
given CDP is owned by the given account.

<pre>
owns id_urn id_lad =
  want (look (vat . urns . ix id_urn . lad)) (== id_lad)
</pre>
<p>We define <code>auth k</code> as an act modifier that executes
<code>k</code> only if the sender is authorized.

<pre>
auth continue = do
  s &lt;- use sender
  unless (s == God) (throwError AuthError)
  continue
</pre>
<!--

\chapter{Testing}

Sketches for property stuff...

<pre>
{-
data Parameter =
     Wut | Par | Way

maintains
  :: Eq a  =&gt; Lens' System a -&gt; Action ()
           -&gt; System -&gt; Bool

maintains p = \ m sys0 -&gt;
  case exec sys0 m of
  -- On success, data must be compared for equality
    Right sys1  -&gt; view p sys0 == view p sys1
  -- On rollback, data is maintained by definition
    Left _      -&gt; True

changesOnly
  ::  Lens' System a -&gt; Action ()
  -&gt;  System -&gt; Bool

changesOnly p = \m sys0 -&gt;
  case exec sys0 m of
  -- On success, equalize |p| and compare
    Right sys1  -&gt; set p (view p sys1) sys0 == sys1
  -- On rollback, data is maintained by definition
    Left _      -&gt; True

also :: Lens' s a -&gt; Lens' s b -&gt; Lens' s (a, b)
also f g = lens getter setter
  where
  getter x = (view f x, view g x)
  setter x (a, b) = set f a (set g b x)

keeps :: Parameter -&gt; Action () -&gt; System -&gt; Bool
keeps Wut  = maintains (vat . vox . wut)
keeps Par  = maintains (vat . vox . par)
keeps Way  = maintains (vat . vox . way)
-}
</pre>
Thus:

<pre>
{- foo sys0 = all (\f -&gt; f sys0)
  [changesOnly (  (vat . vox . par) `also`
                  (vat . vox . way))
     (perform Prod)] -}
</pre>
\appendix

%include Maker/Prelude.lhs
%include Maker/Decimal.lhs
-->

<h1>Glossary</h1>

<glossary>
<dl>

<dt><code>Pride</code>
<dd><code>Pride</code> is the risk stage of a non-risky CDP.

<dt><code>Anger</code><dd><code>Anger</code> is the <code>Stage</code>
of a CDP whose type has reached its issuance ceiling, but has a fresh
price feed; is overcollateralized; and has not been triggered
for liquidation.

<dt><code>Worry</code><dd><code>Worry</code> is the <code>Stage</code>
of a CDP whose asset's price feed has expired yet is still within the
CDP type's grace period; but the CDP is still considered
overcollateralized and has not been triggered for liquidation.  (The
CDP's type may also have reached its issuance ceiling.)

<dt><code>Panic</code><dd><code>Panic</code> is the <code>Stage</code>
of a CDP which is undercollateralized or whose price feed is expired
past the CDP type's grace period; but which has not yet been triggered
for liquidation.  (The CDP's type may also have reached its
issuance ceiling.)

<dt><code>Grief</code><dd><code>Grief</code> is the <code>Stage</code>
of a CDP which has been triggered for liquidation.

<dt><code>Dread</code><dd><code>Dread</code> is the <code>Stage</code>
of a CDP which is undergoing liquidation.

<dt><code>cat</code><dd>The <code>cat</code> of an <code>urn</code> is
the actor which triggered the CDP's liquidation, if applicable.

<dt><code>ink</code><dd>The <code>ink</code> of an <code>Urn</code>
(type: <code>Wad</code>) is the quantity of asset token locked in the
corresponding CDP.

<dt><code>zzz</code><dd>The <code>zzz</code> of a <code>Tag</code>
(type: <code>Sec</code>) is the timestamp at which the corresponding
asset price tag will expire.

<dt><code>lax</code><dd>The <code>lax</code> of an <code>Ilk</code>
(type: <code>Sec</code>) is the grace period for expired asset price
tags applying to CDPs of the corresponding type.

<dt><code>hat</code><dd>The <code>hat</code> of an <code>Ilk</code>
(type: <code>Wad</code>) is the maximum total ("ceiling") dai issuance
for the corresponding CDP type.

<dt><code>tag</code><dd>The <code>tag</code> of a <code>Tag</code>
record (type: <code>Wad</code>) is the recorded market price of the
corresponding asset token denominated in SDR.

<dt><code>rum</code><dd>The <code>rum</code> of an <code>Ilk</code>
(type: <code>Wad</code>) is the total current issuance for the
corresponding CDP type, denominated in the CDP's internal fee unit.

<dt><code>chi</code><dd>The <code>chi</code> of an <code>Ilk</code>
(type: <code>Ray</code>) is the dai valuation for the corresponding
CDP type's internal fee unit, compounding over time according to the
CDP type's stability fee.

<dt><code>mat</code><dd>The <code>mat</code> of an <code>Ilk</code>
(type: <code>Ray</code>) is the minimum required collateralization
ratio (value of collateral divided by value of issued dai) for CDPs of
the corresponding CDP type.

<dt><code>has</code><dd><code>has k x</code> is true if the field
<code>k</code> of the record <code>x</code> is not
<code>Nothing</code>.

</dl>
</glossary>

<script src=maker.js></script>
